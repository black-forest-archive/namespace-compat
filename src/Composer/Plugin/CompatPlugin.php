<?php
/**
 * Composer Namespace Combat
 *
 * PHP version 5
 *
 * @copyright  BlackForest <https://github.com/black-forest>
 * @author     Dominik Tomasi <dominik.tomasi@gmail.com>
 * @author     Sven Baumann <baumannsv@gmail.com>
 * @package    BlackForest\Composer\Plugin
 * @license    LGPL
 */


namespace BlackForest\Composer\Plugin;


use BlackForest\Composer\Compat\Package;
use Composer\Autoload\ClassMapGenerator;
use Composer\Composer;
use Composer\IO\IOInterface;
use Composer\Plugin\PluginInterface;

/**
 * Class CompatPlugin
 * @package BlackForest\Composer\Plugin
 */
class CompatPlugin implements PluginInterface
{
    protected $composer;

    protected $io;

    protected $package;

    protected $compat;

    /**
     * activate the composer plugin
     *
     * @param Composer $composer
     * @param IOInterface $io
     */
    public function activate(Composer $composer, IOInterface $io)
    {
        $this->composer = $composer;
        $this->io = $io;

        /** @var \BlackForest\Composer\Compat\Package $package */
        $combatCackage = new Package($composer);
        $combatCackage->compile();

        if (count($combatCackage->package) > 0) {
            $this->package = $combatCackage->package;
            $this->createCompat();
        }

        $this->createCompatFile();
    }

    protected function createCompat()
    {
        /** @var \Composer\Autoload\ClassMapGenerator $generator */
        $generator = new ClassMapGenerator();
        $compat = array();

        foreach ($this->package as $package) {
            $map = array();
            if (array_key_exists('package', $package) && array_key_exists('autoload', $package)) {
                foreach ($package['autoload'] as $type) {
                    if (count($type) > 0) {
                        foreach ($type as $source) {
                            if (count($source) > 0) {
                                foreach ($source as $item) {
                                    $map = array_merge($map, $generator->createMap($item));
                                }
                            } else {
                                $map = array_merge($map, $generator->createMap($source));
                            }
                        }
                    }
                }
            }

            foreach ($map as $newClass => $classSource) {
                $namespaceCompat = $package['package']->getExtra()['namespace-compat'];

                foreach ($namespaceCompat as $oldNamespace => $newNamespace) {
                }

                if ($newClass === $newNamespace) {
                    array_push($compat, array($oldNamespace => $newClass));
                }

                if ($newClass != $newNamespace) {
                    if (!array_key_exists($oldNamespace, $compat)) {
                        $compat = array_merge($compat, array($oldNamespace => array()));
                    }

                    $oldClass = explode('\\', $newClass);
                    unset($oldClass[0]);
                    $oldClass = implode('\\', $oldClass);

                    $compat[$oldNamespace][$newClass] = $oldNamespace . '\\' . $oldClass;
                    $compat[$oldNamespace]['package'] = $package['package'];
                }
            }
        }

        ksort($compat);
        foreach ($compat as &$value) {
            ksort($value);
        }

        $this->compat = $compat;
    }

    /**
     * create the content for namespace_compat.php
     */
    protected function createCompatFile()
    {
        $content = '<?php
/** namespace_compat.php @generated by NamespaceCompat */


';
        if (is_array($this->compat)) {
            foreach ($this->compat as $old => $new) {
                $content .= '/** package ' . $new['package']->getPrettyName() . ' */'. "\n";
                unset($new['package']);

                if (count($new) < 0) {
                    $content .= 'class ' . $old . ' extends \\' . $new . ' {}';
                }

                if (count($new) > 0) {
                    foreach ($new as $newClass => $oldClassAsNamespace) {
                        $oldClassAsNamespace = explode('\\', $oldClassAsNamespace);
                        $oldClass = array_pop($oldClassAsNamespace);
                        $oldNamespace = implode('\\', $oldClassAsNamespace);
                        $content .= 'namespace ' . $oldNamespace . ' {
    class ' . $oldClass . ' extends \\' . $newClass . ' {}
}
';
                    }
                }
                $content .= "\n";
                $content .= "\n";
            }
        }

        $this->saveFile($content);
    }

    /**
     * create the file namespace_compat.php
     *
     * @param $content
     * @return bool
     */
    protected function saveFile($content)
    {
        if ($content === '') {
            return false;
        }

        $filePath = '';

        /** @var \Composer\Repository\InstalledFilesystemRepository $localRepository */
        $localRepository = $this->composer->getRepositoryManager()->getLocalRepository();
        $namespaceCompatPackage = $localRepository->findPackages('blackforest/namespace-compat');
        $vendorPath = $this->composer->getConfig()->get('vendor-dir');

        // $namespaceCompatPackage is an base package
        if (count($namespaceCompatPackage) < 1) {
            $filePath .= $vendorPath;

            if (!file_exists($filePath . '/composer.json')) {
                $findBasePath = true;

                while ($findBasePath) {
                    $filePath .= dirname($filePath);
                    if (file_exists($filePath . '/composer.json')) {
                        $findBasePath = false;
                    }
                }
            }
        }

        // $namespaceCompatPackage is installed as vendor package
        if (count($namespaceCompatPackage) > 0) {
            /** @var \Composer\Installer\InstallationManager $installationManager */
            $installationManager = $this->composer->getInstallationManager();

            foreach ($namespaceCompatPackage as $searchPackage) {
                if ($searchPackage->getPrettyName() === 'blackforest/namespace-compat') {
                    $filePath = $installationManager->getInstallPath($searchPackage);
                }
            }
        }

        $filePath .= '/compat';
        if (!is_dir($filePath)) {
            mkdir($filePath, 0777);
        }

        $filePath .= '/namespace_compat.php';
        file_put_contents($filePath, $content);

        $this->io->write('<info>Generating namespace_compat.php file</info>');

        return true;
    }
}