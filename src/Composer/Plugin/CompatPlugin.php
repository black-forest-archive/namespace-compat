<?php
/**
 * Composer Namespace Combat
 *
 * PHP version 5
 *
 * @copyright  BlackForest <https://github.com/black-forest>
 * @author     Dominik Tomasi <dominik.tomasi@gmail.com>
 * @author     Sven Baumann <baumannsv@gmail.com>
 * @package    blackforest/namespace-compat
 * @license    LGPL
 */


namespace BlackForest\Composer\Plugin;


use BlackForest\Composer\Compat\Package;
use Composer\Autoload\ClassMapGenerator;
use Composer\Composer;
use Composer\EventDispatcher\EventSubscriberInterface;
use Composer\Installer\InstallerEvents;
use Composer\Installer\PackageEvents;
use Composer\IO\IOInterface;
use Composer\Package\BasePackage;
use Composer\Package\CompletePackage;
use Composer\Plugin\PluginEvents;
use Composer\Plugin\PluginInterface;
use Composer\Plugin\PluginManager;
use Composer\Script\ScriptEvents;

/**
 * Class CompatPlugin
 * @package blackforest/namespace-compat
 */
class CompatPlugin implements PluginInterface, EventSubscriberInterface
{
    protected $composer;

    protected $io;

    protected $package;

    protected $compat;

    /**
     * activate the composer plugin
     *
     * @param Composer $composer
     * @param IOInterface $io
     */
    public function activate(Composer $composer, IOInterface $io)
    {
        $this->composer = $composer;
        $this->io = $io;
    }

    public static function getSubscribedEvents()
    {
        return array(
            PackageEvents::POST_PACKAGE_INSTALL => 'handlePostPackageInstall',
            PackageEvents::POST_PACKAGE_UPDATE => 'handlePostPackageUpdate',
            InstallerEvents::POST_DEPENDENCIES_SOLVING => 'handlePostDependenciesSolving'
        );
    }

    public function handlePostPackageInstall()
    {
        $this->handlePostDependenciesSolving();
    }

    public function handlePostPackageUpdate()
    {
        $this->handlePostDependenciesSolving();
    }

    public function handlePostDependenciesSolving()
    {
        /** @var \BlackForest\Composer\Compat\Package $package */
        $combatCackage = new Package($this->composer);
        $combatCackage->compile();

        if (count($combatCackage->package) > 0) {
            $this->package = $combatCackage->package;
            $this->createCompat();
        }

        $this->createCompatFile();
    }

    /**
     * find all compat package and push to $this->compat
     */
    protected function createCompat()
    {
        /** @var \Composer\Autoload\ClassMapGenerator $generator */
        $generator = new ClassMapGenerator();
        $compat = array();

        foreach ($this->package as $package) {
            $map = array();
            if (array_key_exists('package', $package) && array_key_exists('autoload', $package)) {
                foreach ($package['autoload'] as $type) {
                    if (count($type) > 0) {
                        foreach ($type as $source) {
                            if (count($source) > 0) {
                                foreach ($source as $item) {
                                    $map = array_merge($map, $generator->createMap($item));
                                }
                            } else {
                                $map = array_merge($map, $generator->createMap($source));
                            }
                        }
                    }
                }
            }

            foreach ($map as $newClass => $classSource) {
                $namespaceCompat = $package['package']->getExtra()['namespace-compat'];

                foreach ($namespaceCompat as $oldNamespace => $newNamespace) {
                }

                if ($newClass === $newNamespace) {
                    array_push($compat, array($oldNamespace => $newClass));
                }

                if ($newClass != $newNamespace) {
                    if (!array_key_exists($oldNamespace, $compat)) {
                        $compat = array_merge($compat, array($oldNamespace => array()));
                    }

                    $oldClass = explode('\\', $newClass);
                    unset($oldClass[0]);
                    $oldClass = implode('\\', $oldClass);

                    $compat[$oldNamespace][$newClass] = $oldNamespace . '\\' . $oldClass;
                    $compat[$oldNamespace]['package'] = $package['package'];
                }
            }
        }

        ksort($compat);
        foreach ($compat as &$value) {
            ksort($value);
        }

        $this->compat = $compat;
    }

    /**
     * create the content for namespace_compat.php
     */
    protected function createCompatFile()
    {
        $content = '<?php
/** namespace_compat.php @generated by NamespaceCompat */


';
        if (is_array($this->compat)) {
            foreach ($this->compat as $old => $new) {
                $content .= '/** package ' . $new['package']->getPrettyName() . ' */' . "\n";
                unset($new['package']);

                if (count($new) < 0) {
                    $content .= 'class ' . $old . ' extends \\' . $new . ' {}';
                }

                if (count($new) > 0) {
                    foreach ($new as $newClass => $oldClassAsNamespace) {
                        $oldClassAsNamespace = explode('\\', $oldClassAsNamespace);
                        $oldClass = array_pop($oldClassAsNamespace);
                        $oldNamespace = implode('\\', $oldClassAsNamespace);
                        $content .= 'namespace ' . $oldNamespace . ' {
    class ' . $oldClass . ' extends \\' . $newClass . ' {}
}
';
                    }
                }
                $content .= "\n";
                $content .= "\n";
            }
        }

        $this->saveFile($content);
    }

    /**
     * create the file namespace_compat.php
     *
     * @param $content
     * @return bool
     */
    protected function saveFile($content)
    {
        if ($content === '') {
            return false;
        }

        $vendorPath = $this->composer->getConfig()->get('vendor-dir');

        $filePath = $vendorPath;
        $filePath .= '/blackforest/namespace-compat/compat';
        if (!is_dir($filePath)) {
            mkdir($filePath, 0777);
        }
        $filePath .= '/namespace_compat.php';

        file_put_contents($filePath, $content);

        $this->io->write('<info>Generating namespace_compat.php file</info>');

        return true;
    }
}